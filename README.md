
## Introduction

extprot allows you to create compact, efficient, extensible, binary protocols
that can be used for cross-language communication and long-term data
serialization.  extprot supports protocols with rich, composable types, whose
definition can evolve while keeping both forward and backward compatibility.

The extprot compiler (extprotc) takes a protocol description and generates
code in any of the supported languages to serialize and deserialize the
associated data structures. It is accompanied by a runtime library for each
target language which is used to read and write the structures defined by the
protocol.

The protocols created using extprot are:

* extensible: types can be [extended in several ways](doc/extensions.md)
  without breaking compatibility with existent producers/consumers
* self-delimited: each message indicates its own length. This allows to
  send a sequences of messages (streaming).
* self-describing: a message can be decoded even without the protocol
  definition. What you get is roughly equivalent to XML without the DTD.
* compact
* fast: can be deserialized one to two orders of magnitude faster than XML

There are three parts to extprot, from lower to higher level:

1. the [low-level encoding](doc/encoding.md)
1. the [abstract syntax to define the protocol](doc/protocol-definition.md)
1. the [mapping to the target language](doc/language-mapping.md)

The [abstract syntax](doc/protocol-definition.md) is what the extprot user
feeds to the extprotc compiler; it defines the protocol, and controls how it
maps to both the low-level encoding and the [target language's data
model](doc/language-mapping.md).

The [low-level encoding](doc/encoding.md) is of interest to people who want to
add support for additional target languages --- knowledge of the low-level
encoding is obviously needed for the required runtime.

## Example

Here's a trivial protocol definition:

    (* this is a comment (* and this a nested comment *) *)
    message user = {
      id : int;
      name : string;
    }

The value

    { id = 1; name = "J.R.R. Tolkien" }

is serialized as (bytes in decimal notation plus ASCII characters between
quotes) this 20-byte message:

    001 019 002 000 002 003 014 "J.R.R Tolkien"

The code generated by extprotc allows you to manipulate such messages as any
normal value. For instance, in the Ruby target (in progress as of 2008-11-04),
you'd do:

    # writing
    puts "About to save record for user #{user.name}"
    user.write(buf)
    # save buf

    # reading
    user = User.read(io)
    puts "Got user #{user.id} #{user.name}"

In OCaml, the message is simply a record:

    let u = User.read_user stream in
      printf "User %S has got id %d\n" u.name u.id

